type: note
init_time: '2020-02-16 22:15:33.313424'
parents:
- d7c97fb962ebeec3827179ecd2471c7720a8d86d
title: cf's 1296C problem
text: "我又被卡住啦！鼓掌！（啪啦啪啦）\n\n这道题看起来很像是dp的题嘛，\n但是没有想到不行欸，也是哈，毕竟是$O(n^2)$嘛。\n\n这道题意思如下：有一个字符串，\n\
  要寻找它的最短的符合规则的连续子字符串，\n而所谓规则，\n就是该字符串中的\\code{'U'}和\\code{'D'}，\n\\code{'R'}和\\code{'L'}的数量两两相等。\n\
  \n我是这么想的：\n定义一个结构体$y = f(str)$来存储$str[i..j]$的四个值，\n于是结构体满足：\n$y_{i..j}=f(str[i..j])=f(str[i..j-1]+str[j])=\n\
  y_{i..j-1}+f(str[i])$\n\n虽然我是菜鸡，但是动态规划什么的，\n自底向上简简单单的啦。\n说着我啪嗒啪嗒敲好了代码，\n还为结构体重载了运算符。\n\
  \n结果\\code{time limit}，也是毕竟是$O(n^2)$的算法嘛，\n暴力也是$O(n^2)$的复杂度对吧。\n\n但是真的有比这个好的算法吗\\\
  ldots\\ldots\n\n\\subsection{其他人的答案}\n还是有更好的方法，这道题的目的就是为了找到$i$和$j$，\n但是并没有必要找到$1\\\
  le i\\le j\\le len$中%\n所有满足的$a[i..j]$的数据结构，因为这样子，\n时间复杂度为$O(len^2)$。\n\n但是从另外一种方向考虑的话，\n\
  这种题目的数据结构是有它的特点的：\n对于$a[1..i]$和$a[1..j]$来说的话，\n如果增加的\\code{'U'}和\\code{'D'}，\n增加的\\\
  code{'R'}和\\code{'L'}两两相等的话，\n那么一定$a[i..j]$满足条件。\n\n如果把所有的$a[1..i]$都储存下来，\n当一个数据结构相等的时候，就可以肯定，\n\
  我们找到了一个符合条件的值。\n\n综上，时间复杂度可以降到$O(n \\text{lg }n)$，\n甚至是$O(n)$（如果用哈希表的话）。\n"
