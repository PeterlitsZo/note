%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\LaTeX{}中的盒子寄存器}

盒子有三个值：宽度，高度和深度，盒子的实际高度是高度和深度的值的和，分割它们的是
基线。

在盒子中可以使用\vb|\width|，\vb|\height|和\vb|\depth|，\vb|\totalheight|来表示
所有的自然值。

对于盒子寄存器来说，可以使用：
\begin{lstlisting}
\newbox\BOX         % or \newsavebox{\BOX}
\sbox\BOX{<BOX>}    % or \setbox\BOX=<BOX> or \savebox{\BOX}{<BOX>}
\usebox{\BOX}
\end{lstlisting}

使用上面的三个命令可以用来声明、赋值和使用盒子。关于盒子它有一些属性，可以用%
\vb|\ht|、\vb|\wd|和\vb|\dp|来获取。

\vb|\newsavebox|会检查名字是否被使用过。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{关于Mr.Jackson Walter的洛必达直观解释}

本文来自\url{https://math.stackexchange.com/questions/98082/why-does-lh\%C3\%B4pitals-rule-work}

洛必达首先是有两种情况，而这两种情况下都能使用：

\begin{enumerate}
    \item 如果$\lim_{x\to a}f(x)=0$并且$\lim_{x\to a}g(x)=0$的情况下，那么存在：
        \[\lim_{x\to a}\frac{f(x)}{g(x)}=\frac{f'(x)}{g'(x)}\]
    \item 如果$\lim_{x\to a}f(x)=\infty$并且$\lim_{x\to a}g(x)=\infty$的情况下，那么存在：
        \[\lim_{x\to a}\frac{f(x)}{g(x)}=\frac{f'(a)}{g'(a)}\]
\end{enumerate}

洛必达的直观解释是，假设有一个点，它的$x$坐标是$f(x)$而它的$y$坐标是$g(x)$，那么该点%
$t$满足：
\[ t \to [f(x), g(x)] \]

当$x\to a$的时候，两个坐标都趋向于零，那么比率$\frac{f(x)}{g(x)}$的几何涵义是$(0, 0)$点
处的斜率，而该店的切线由$[f'(x), g'(x)]$给出，所以洛必达定理指出，趋于零点处的切线斜率就是
趋于零点处的斜率的极限。

（好吧我好像还是没有很懂的样子）


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\LaTeX{}中的扩展和非扩展}

\subsection{关于def和edef、let命令}

作为一个宏标记语言，很多东西都是需要扩展到不可扩展的地步的。比如说常用的\vb|\def|%
和\vb|\newcommand|定义出的命令都是可扩展的，在求值时会主动扩展，递归到不可扩展时。
而\vb|\edef|则会先将命令体完全扩展开来再赋值：
\begin{lstlisting}
\def\txt{a}
\def\foo{\txt}
\let\bar\foo
\bar -> a
\def\txt{b}
\bar -> b
\end{lstlisting}

或者：
\begin{lstlisting}
\def\txt{a}
\def\foo{\txt}
\edef\bar{\foo}
\bar -> a
\def\txt{b}
\bar -> a
\end{lstlisting}

可以看到这两个之间呈现出了不同的结果。这是因为\vb|\def|不会扩展group但是\vb|\edef|%
会尝试扩展了之后在赋值给自定义的扩展命令。（我的天，这太绕口了）当然\vb|\let|%
也和这个很像，它会得到值而不是命令本身。

\subsection{关于显示宏}

我们有三个工具用来搞定这个：\vb|\show|，\vb|\showthe|，\vb|\the|来显示命令，
其中\vb|\show|会显示出它的扩展后的样子，\vb|\the|则会将命令指定的寄存器扩展到
原位置。自然，\vb|\showthe|是用来显示寄存器的值的命令。

一般而言，寄存器中储存数字，长度，弹性长度，盒子等等。

对于Lua\LaTeX{}而言，值得注意的是：\vb|\luadirect|是可以扩展的。而其它的运行环境可能
不是可扩展的。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\LaTeX{}中的begingroup和endgroup}
 
\subsection{前言}

看了看别人写的代码，定义的环境中存在\vb|\begingroup|和\vb|\endgroup|的情况下，
好像定义的命令和变量都神奇的具有局部作用域！我之前一直以为它们都是作用在全局中
的。

我在翻看一个关于日历表的\LaTeX{}宏包源代码的时候，发现用\vb|\def|来重命名了命令%
\vb|\day|，而之后又神奇的出现了。尴尬的是，当我删除命令\vb|\begingroup|和%
\vb|\endgroup|的时候，它还是令人惊喜的具有局部作用域。

好吧\vb|\newenvironment|也很厉害，它有局部作用域。我现在彻底搞糊涂了，\TeX{}的原
理很简单，但是一旦搞到\LaTeX{}上面去的话，就各种奇怪的现象都出来了。

\subsection{关于environment中的作用域}

我声明了一个环境：
\begin{lstlisting}
\newenvironment{test}{
    \def\day{TEST TEST TEST}
}{}
\end{lstlisting}

我发现在环境中使用和脱离环境后，\vb|\day|是不一样的。那\vb|\begingroup|到底有什
么用呢？

\subsection{环境中使用\verb|bgroup|和\verb|egroup|}

不是每一个都支持这两个命令的，但是最基本的\vb|\hbox|和\vb|\vbox|是毫无疑问支持的
，为了在这里面使用这两个命令，我定义了如下的环境：
\begin{lstlisting}
\newbox\fuckbox
\newenvironment{fuck}{
    \setbox\fuckbox=\hbox\bgroup
}{%
    \egroup
    {}\hfill%
    \parbox{0.8\textwidth}{\leavevmode\box\fuckbox}
}
\end{lstlisting}

忽略不雅词汇，我们可以看到我们巧妙的让\vb|\hbox|接受了\vb|\bgroup|和\vb|\egroup|。
这是一个好事情。它把盒子储存在盒子变量里面。

可以看到！它利用\vb|\bgroup|和\vb|\egroup|用来接受所有的字符，然后最后的时候突然
来跳出来画一个盒子。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{停机问题}

我这次又听说了停机问题，干脆趁这个时候随便做出来一哈。

在了解停机问题之前我们需要理解理发师悖论。

\subsection{理发师悖论}

举一个例子，我们有一个集合$A$，它的元素是所有不包含自己的元素。
比如说$1$中不包含自己，所以它属于$A$，空集$\varnothing=\{\}$中不包含任何
元素，当然也不可能包含自己，所以空集也属于集合$A$。

而对于反例来说，比如说$B=\{B,\{\}\}$而言，它就包含了自己（当然也包含了空集）
，就不能进入$A$的集合。

现在的问题是：$A$能不能包含自己？分类讨论：

\begin{enumerate}
    \item \emph{$A$包含自己}：\par
        如果$A$包含自己的话，那么$A$就不能进入自己的集合，就和集合$B$一样。
        \pltred 于是$A$不包含自己，矛盾。\pltblack
    \item \emph{$A$不包含自己}：\par
        如果$A$不包含自己的话，那么显然和空集一样应该纳入$A$中成为$A$中的
        一个元素。\pltred 于是$A$包含自己，矛盾。\pltblack
\end{enumerate}

所以说集合论的基础因为罗素悖论\footnote{这是罗素悖论，它本质上和理发师
悖论等价，但是利用使用用数学语言的罗素悖论会更好描述后面的停机问题。}%
而发生了崩塌，即，集合论在处理包含自己的集合的时候会存在一定的逻辑漏洞。

\subsection{停机问题}

停机问题和罗素问题的落脚点都很像，主要落脚在处理自己上从而找到逻辑漏洞。

我们先假设有一个图灵机$T$，它能判断另外的一个图灵机对于特定输入会不会
停机（\emph{halt}）。既有：

$$T(S,i) \Longrightarrow \text{\verb|<bool>|}$$

其中$S$是另一个图灵机，而$i$是特定的输入。

于是我们模仿罗素悖论中的“包含着所有不包含自己的对象的集合对象”和
“给所有不给自己理发的同学理发的同学”一样，我们构建一个本质上和它一样的图灵机：
\begin{lstlisting}[language=Python]
U(S: function) -> None:
    # if S will halt for input S
    if T(S, S):
        # non-halt
        while True: pass
    # if S will not halt for input S
    else:
        # halt
        return
\end{lstlisting}

可以看到，$T$是用来判断是否图灵机$S$会对输入$i$停机的图灵机。
所以$U$的意思就是：“如果输入是不停机的图灵机，那本身就停机
（同时，如果输入是会停机的图灵机，则自己就不停机）”。模仿罗素悖论，
我们给它传入自己：

$$U(U)$$

我们开始在外面观察它是否会停机（因为我们是全知全能的神，当然能判断它
到底停没有停机）。$U$对函数$U$而言显然有两种结果，列表如下：

\begin{enumerate}
    \item \emph{$U$对于输入$U$不停机}：\par
        这说明$U$对于输入$U$会停机。%
        \pltred 但我们的观察结果是$U$对于输入$U$不会停机，矛盾。\pltblack%
    \item \emph{$U$对于输入$U$停机}：\par
        这说明了$U$对于输入$U$不会停机。{\pltred%
        但是我们的观察结果是$U$对于输入$U$会停机，矛盾。}%
\end{enumerate}

所以说，不可能存在一个图灵机，可以判断出任何图灵机是否停机。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lua\LaTeX{}的使用}

今天为了解决计算时间太慢的问题，找了一下Lua\LaTeX{}的tutorial，发现的确不错，
对于我来说，只需要改动一点点地方就可以运行，能够完美支持\vb|ctexart|的底层就是
一个好底层。

而我最喜欢的就是：它本身可以运行Lua代码，而这个代码的速度是非常非常快的，作为
一个脚本语言做到这么快还是不容易，而且标准库的算法很不错。（我就是因为，原来
的宏包把时间转换为具体的时间很慢才找到Lua\LaTeX{}的，我翻译原来的那个，是每一
次都从头加到尾，还要判断闰年什么的，不建表）。

其次，宏展开是优先于运行代码的，所以很容易很容易就可以向Lua传入参数，输出就用%
\vb|luadreact|（好像不是这么写的），输出到原文件中，就像用\vb|JavaScript|来操纵%
\vb|HTML|一样。太棒了啦。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\LaTeX{}的长度}

最近，在写\LaTeX{}宏包的时候，出现了一点幽灵长度，我总是搞不清楚，为什么高一点
的和矮一点的间距不平等，后来我终于搞懂了，记录在案。

\subsection{段落、文字行之间的间距}

一般来说，两个段落之间是由宏\vb|\par|而隔开的，所以说那两个段落之间的竖直盒子
是由\vb|\par|命令决定的，而\vb|\par|以变量，长度寄存器变量\vb|\parskip|来决定，
它的值是\vb|0pt plus 1pt|，弹性长度下限一定是固定的，但是上限不是固定了（当然
如果超过上限太多了，那它就是一个坏盒子了）。

文字行之间的间距，这是由\vb|\baselineskip|决定了。这就是说，如果我的这一行盒子
都差不多是一个字符高的话，那么它乖乖地采用下限，留出好看的间隙，如果超过了，那
它的高度就不是上限了，而是它本身的高度了。

\subsection{解决方案}

定义\vb|\baselineskip|为\vb|0pt|，这样的话，无论是多高的话，它的高度就是它本身
高度了，而不会留间隙，固定的间隙应该用\vb|vspace*|来代替它，用在两个命令之间，
构建一个漂亮的间隙。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{HDU-6400题解}

杭州电大的ACM官网好慢哦，注册一下又要等半天。
然后好像官网的题解也没有，有点难受。

\subsection{题目}

这道题，说的是有一个括号矩阵，给定了$n$和$m$作为
长和高，然后让行匹配和列匹配的个数最多。
那么什么情况下是匹配的呢：一个正向括号就是匹配的，
反之则不匹配。

比如：
\begin{lstlisting}
1.          2.              3.
(()())      ((()(())))      (
                            )
                            (
                            )
\end{lstlisting}

这三个分别有行匹配和列匹配的情况。计数为1。我们
要对于给定$n$和$m$而言选定计数最大的进行输出。
很明显，这个不是唯一的。

\subsection{想法}

在做这个之前我有一点想法，但是做错了。

首先对于正向括号序列而言，那么有：它的长度$len$一定满足：%
$$len (\text{mod } 2) = 0$$

所以说如果这个是一个奇数（odd number）的话，无论如何也不可能是一个正向括号序列。
所以有：

\begin{enumerate}
\item $n$和$m$都是奇数，那么计数$cnt$一定是零。
\item $n$是奇数但是$m$不是，那么计数$cnt$为$n$（因为$n$对应的那一个构造成正向括号
的话，计数$cnt$就为$n$，这个时候是最优解）。反之亦然。
\item 我感觉最难的\vb|>_<|，那就是$n$和$m$都是偶数。这种情况下我想了一个绝妙的想法
那就是，令$a=max(n, m)$，$b=min(n,m)$，那么有如果我把$a$对应的行/列都改成正向括号
序列，那么答案计数$cnt$就是$a$了。但是不够，后来我有想到：
\begin{lstlisting}
(()) => (())
()() => ()  ()
(()) => (())
()() => ()  ()
\end{lstlisting}

像这种的话，就太棒了！首先它本身有四个正向序列构成。还见缝插针的搞了一个竖的（第二列
）所以说，只要我在原有基础上多插插就有多的了。这个时候，计数$cnt$的值就为%
$a+\frac{b}{2}-1$，其中$\frac{b}{2}$是因为原第一排只有一半是开括号，可以用来
构建正向序列，减一是因为第一个开括号是不能搞事情的。

\subsection{题解}

只能说我想到了一点但是没有想到第二点。这道题需要构建正向括号序列，但是其实
正向的它的本质是开头是\vb|(|末尾是\vb|)|然后其他的只要保证中间不跌下到-1（
正向序列的值，意思是有没有匹配上的\vb|)|反括号）并且末尾为零就好了。

那么这么看的话，
\begin{lstlisting}
.((((((. => .((((((.
(......) => ()()()()
(......) => (()()())
(......) => ()()()()
(......) => (()()())
.)))))). => .)))))).
\end{lstlisting}

上面的才是最优解，只要它中间那一坨能够满足的话整个的计数就是$cnt=a+b-4$，
两个式子比较有\begin{align}&(a+b-4)-(a+\frac{b}{2}-1)\\&=b-\frac{b}{2}-3\\
&=\frac{b}{2}-3\\&>0\\&\Longrightarrow b>6\end{align}，所以说在大一点的时候
应该用这个方法会比较好一点。

\end{enumerate}
