
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{GoLang的枚举}

GoLang没有枚举，所以可以使用 \verb|const| 来模拟，结合它比较独特的语法结构，我们
可以使用如下的表达方式：
\begin{lstlisting}
const (
    begin = 0
    up    = 1
    end   = 2
)
\end{lstlisting}

像C++那种，到头来枚举到底还是污染了命名空间，不然直接用 \verb|const| 来得爽快。

当然类似C++那种而言，我们也可以尝试定义一个新的类型，这很简单：
\begin{lstlisting}
type State int32
const (
    begin State = 0
    up    State = 1
    end   State = 2
)
\end{lstlisting}

而为了更好的定义，还可以使用在每行自动加1的关键字 \verb|itoa|，和它附带的默认重
复表达式，比如：
\begin{lstlisting}
type Byte float32
const (
    _ = itoa
    KB Byte = 1 << (10*iota)
    MB
    GB
    TB
    PB
)
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section[LeetCode-1007题解]{LeetCode-1007题解\footnote{更多详情请见\url{https:/%
/leetcode-cn.com/problems/minimum-domino-rotations-for-equal-row/}。}}

\subsection{题干}

在一排多米诺骨牌中，$A_i$和$B_i$分别代表第$i$个多米诺骨牌的上半部分和下半部分。
（一个多米诺是两个从$1$到$6$的数字同列平铺形成的 --- 该平铺的每一半上都有一个数
字。）

我们可以旋转第$i$张多米诺，使得$A_i$和$B_i$的值交换。

返回能使$A$中所有值或者$B$中所有值都相同的最小旋转次数。

如果无法做到，返回$-1$。

\subsection{致命的错误}

我一开始看的时候，想法是：旋转完了之后，相同的那一侧一定是包含着$A_0$或者$B_0$。
所以我一开始就对$A_0$求旋转次数，然后对$B_0$同理。

然后WA。我仔细思考了一下，发现我之前是尝试着把不等于$A_0$的$A_i$旋转并递增 \verb
|cnt| 。这样的话，我就用$B_i$来代替了$A_i$的位置。也也就是说，我完全是把$B$中的
东西补到$A$中去。而不是把$A$中补到$B$中去。然后想当然的认为后者的实现次数是
\verb|A.len - cnt| 而不是其他的。然后接着WA。

这是因为，我没有考虑到有些骨牌旋转后保持不变，这种时候我就是多此一举了，白白让 
\verb|cnt|增加，但是基本上不改变局面。其实对$A$补到$B$的情况下和反过来几近同理，
只需要重复一次或者维持两个变量就行了。

特此记下。

\subsection{贪心算法の思考}

我现在的话，也特地专门做了4、5道关于贪心的题目。我的想法就是：贪心就是历史的车轮
不开倒车，子结构最优决定了总结构最优。更多的还没有发现。

